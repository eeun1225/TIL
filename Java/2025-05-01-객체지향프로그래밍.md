# 📚 객체지향프로그래밍 (2025.05.01)
___

## 🌟 오늘 배운 내용
- 객체지향언어의 주요 특징
- 클래스와 객체
- 변수, 메서드, 오버로, 생성자
- 상속
- 다형성
- 캡슐화
- 추상화

<br/>

## 🔎 요약 정리

___

### ✅ 객체지향언어의 주요 특징

- 코드의 재사용성이 높다.
- 코드의 관리가 용이하다
- 신뢰성이 높은 프로그래밍을 가능하게 한다.


### ✅ 클래스와 객체

클래스 : 객체를 정의해 놓은 것. 객체를 생성하는데 사용.

객체 : 실제로 존재하는 것.(사물 또는 개념) 속성과 기능의 집합.
- 멤버 : 객체가 가지고 있는 속성과 기능.
- 속성 → 멤버 변수
- 기능 → 메서드


원하는 기능의 객체를 사용하기 위해서는 클래스로부터 객체 생성 과정이 필요하다.
- 클래스를 정의하고 클래스를 통해 객체를 생성하는 이유
→ 하나의 클래스를 잘 만들면 여러 개의 객체를 만드는 일이 쉽기 때문이다.


인스턴스화 : 클래스로부터 객체를 만드는 과정.

- 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.


객체 배열 : 참조변수들을 하나로 묶은 참조변수 배열
- 배열에 객체의 주소를 저장하는 것
- 배열 초기화 필요.


### ✅ 변수

변수 선언 위치에 따라 달라진다.

- 인스턴스 변수
    - 인스턴스 생성할 때 생성.
    - 클래스 영역
    - 별도의 저장공간 → 인스턴스마다 서로 다른 값 가능.
    - 인스턴스마다 고유한 상태를 유지해야하는 경우에 선언.
- 클래스 변수
    - 클래스가 메모리에 올라갈 때
    - 클래스 영역
    - 인스턴스 생성하지 않고도 사용 가능. (클래스이름.클래스변수)
    - 모든 인스턴스가 공통된 저장공간 공유 (static)
    - 인스턴스들이 공통적인 값을 유지해야하는 경우에 선언.
- 지역 변수
    - 변수 선언문이 수행되었을 때
    - 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부)
    - 사용하기 전에 반드시 초기화해야 함.
    - 메서드 내에 선언되어 메서드 내에서만 사용 가능.
    - 메서드 종료 시 소멸.

**변수 초기화 순서**

클래스 변수 초기화 → 인스턴스 변수 초기화

자동 초기화 → 명시적 초기화(변수 선언과 동시에 초기화) → 초기화 블럭, 생성자


### ✅ 메서드

특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것.

- 선언부
    - 구성 : 반환 타입, 메서드 이름, 매개 변수
- 구현부
    - return문에서 반환 값은 반환 타입과 일치하거나 자동 형변환이 가능한 것이여야 함.
        - void에서는 컴파일러가 자동으로 추가.
    - 지역 변수


**호출스택** : 메서드의 작업에 필요한 메모리 공간을 제공.

- 지역변수들과 연산의 중간 결과 등을 저장
- 메서드 작업을 마치면 메모리 공간이 반환되어 비워짐.
- 특징
    - 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
    - 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
    - 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
    - 아래에 있는 메서드가 바로 위에 메서드를 호출한 메서드이다.

**static은 언제 붙여야 할까 ?**

- 멤버변수 중 모든 인스턴스에 공통으로 사용하는 경우
- 클래스 변수는 인스턴스를 생성하지 않아도 사용 가능
- 클래스 메서드는 인스턴스 변수 사용 불가능
- 메서드 내에서 인스턴스 변수를 사용하지 않는 경우 고려

### ✅ 오버로딩

한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것.

1. 메서드 이름이 같아야한다.
2. 매개변수의 개수 또는 타입이 달라져야 한다.
3. 반환 타입은 관계없다.

### ✅ 생성자

인스턴스 변수들의 초기화에 사용되는 조금 특별한 메서드

1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴 값이 없다. (void 사용 X)
- 생성자도 오버로딩 가능

연산자 new가 인스턴스를 생성하는 것. 생성자가 인스턴스 생성 X

생성자는 반드시 하나 이상 있어야 함. → 하나도 없는 경우에는 컴파일러가 기본 생성자 제공.

this()

- 같은 클래스의 다른 생성자를 호출할 때 사용.
- 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서 호출해야 한다.

this

- 인스턴스 자신을 가리키는 참조변수
- 인스턴스 주소가 저장되어 있다
- 인스턴스 변수와 매개 변수 이름이 같을 때 사용
- this를 사용해서 구별되도록 하는 것이 의미가 더 명확하다
- 인스턴스 멤버만 사용 가능

### ✅ 상속

상위 클래스의 모든걸 하위 클래스가 이어 받는 것

코드의 중복을 없애기 위해 사용한다.

**상속 불가능한 경우**

- 부모 클래스의 private 접근 제한을 갖는 필드 및 메소드는 상속X
- 서로 다른 패키지에 있다면 X
- final 클래스
    - final 메소드 : 오버라이딩 불가 메소드

**클래스 상속**

- extends를 통해 부모 클래스 상속
- super 참조 변수
    - 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 변수
    - 부모클래스의 멤버와 자식클래스 멤버 이름이 같은 경우 super를 통해 구별 가능(this.x = super.x)
- super() : 부모 생성자 호출
    - 부모 기본 생성자는 자식 기본 생성자 맨 첫줄에서 super()형태로 자동 호출
    - 부모가 매개 변수가 있는 생성자만 있다면 자식 생성자에서 반드시 맨 첫줄에 부모 생성자 호출을 위한 super(매개값)을 작성해야함.
- 부모 클래스의 메소드를 자식클래스에서 재정의해 사용할 수 있다. → 오버라이딩
    - 부모 메소드와 동일한 선언부를 가져야 함.
    - 접근 제한을 더 좁은 범위로 오버라이딩 할 수 없음.
    - 새로운 예외를 throws할 수 없음.
- protected 접근자 : 다른 패키지에서는 자식 클래스만 접근 허용

### ✅ 다형성

같은 이름의 메소드를 호출하더라도 객체에 따라 다르게 동작하는 것.

- 하위 클래스에서 오버라이딩하는 것도 다형성으로 볼 수 있음.
- 오버로딩도 다형성으로 볼 수 있음.

다형성의 조건

- 상위 클래스와 하위 클래스는 상속관계여야한다.
- 다형성이 보장되기 위해 오버라이딩 필수.
- 자식클래스의 객체가 부모 클래스의 타입으로 형변환해야한다.

참조변수의 형변환

- 업 캐스팅은 연산자 생략 가능.
- 다운 캐스팅은 연산자 반드시 작성.
- instanceof 연산자 :  참조 변수의 형 변환이 가능한 지의 여부를 boolean 타입으로 반환

### ✅ 캡슐화

관련된 필드와 메소드를 하나로 묶고 실제 구현 내용을 외부로부터 감추는 기법

외부에서는 공개된 메소드를 통해 접근할 수 있다.

- 멤버 변수는 보통 private 키워드 사용해 외부 접근을 막는다.
- setter/getter 메소드를 만들어 내부 데이터에 제한적 접근을 할 수 있다.
    - setter : 외부에서 변수에 데이터를 쓰고자 할 때 사용되는 메소드
    - getter : 외부에서 변수의 데이터를 읽어올 때 사용되는 메소드

### ✅ 추상화

객체에서 공통된 속성과 기능을 추출하는 기법

즉, 공통적인 특성을 파악하고 불필요한 특성 제거하는 과정이다.

설계만하고 구체적인 내용은 작성하지 않는다.

- 추상 클래스 (abstract class)
    - 미완성 클래스이므로 인스턴스 생성 X
    - 상속을 통해 하위 클래스에서만 완성될 수 있다.
    - 새로운 클래스를 작성하는데 유용한 바탕이 되어줌.
- 추상 메서드 (abstract method)
    - 구현부 없이 선언부만 있는 메서드.
    - 하위 클래스로 상속하여 오버라이딩을 통해 메소드를 완성시킨다.
- 인터페이스(interface)
    - 일종의 추상클래스이지만 추상클래스보다 더 높은 추상화 정도를 가진다.
    - 생성자 사용 불가
    - 추상 메소드와 상수만 가질 수 있다. → 메서드 오버라이딩 필수
    - 다중 상속 가능(implements 키워드를 통해 상속)
    - 사용 이유 ? 코드와 인터페이스로 생성된 객체들을 중간에서 중계해주는 역할을 하기 때문에 클래스 간의 결합도를 낮춰준다.